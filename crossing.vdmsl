-- CSC2021 Modelling Coursework Feb 2017
-- Complete the coursework by extending this file as specified
-- in the coursework.
-- Submit your modified copy of this file together with
-- output file generated by using the Run() command.
module Crossing
imports from IO all, from VDMUtil all
definitions

state Crossing of 
  leftBank : Place
  rightBank : Place
  boatPos: Bank
  inv cr == CheckNoDuplicates(cr.leftBank, cr.rightBank) and not Dangerous(cr.leftBank) 
  and not Dangerous(cr.rightBank) --Invarient states the conditions that must be true for the model to work
  init cr == cr = mk_Crossing({<Goat>,<Wolf>,<Cabbage>,<Farmer>},{},<Left>)
  end 
  
  
types

Passenger = <Goat> | <Wolf> | <Cabbage> | <Farmer>; -- items to be transported

Bank = <Left> | <Right>; -- which side the boat is on 

Place = set of Passenger; -- places that passengers may be gathered


functions

-- add functions here
-- write functions to assess conditions
Dangerous: Place -> bool -- Establishes the pairs that cannot be together due to the problem
Dangerous(d) == 
	d = { <Goat> , <Wolf> } or d = {<Goat>,<Cabbage>} or d = {<Goat>, <Cabbage>, <Wolf>}; 

CheckNoDuplicates: Place*Place -> bool --checks to see that the are not duplicates between the two banks
CheckNoDuplicates(left, right) == 
	left inter right = {}; -- the intersection betwwen left bank and right bank should be an empty set

operations

CrossRight: set of Passenger ==> ()  
CrossRight(passengers) ==
	(boatPos := <Right>; -- declares the boat position to be the right bank after crossing
	leftBank := leftBank \ passengers; --shows what is left on the left bank
	rightBank := rightBank union passengers;) --joins the passengers with the right bank
	pre card passengers <= 2 and <Farmer> in set passengers; --checks that there is not more than two passengers 
	-- abd that one of the passengers is the farmer
	
CrossLeft: set of Passenger ==> ()  
CrossLeft(passengers) == 
	(boatPos := <Left>; -- declares the position of the boat to be the left bank after crossing
	rightBank := rightBank \ passengers; -- shows what is left on the right bank
	leftBank := leftBank union passengers;) -- joins the passengers with the left bank
	pre card passengers <= 2 and <Farmer> in set passengers; --checks that there is not more than two passengers
	-- and that one of the passengers is the farmer


Run: () ==> ()
Run() ==
 ( 
  fopen();  -- reopen output file, overwriting current contents
 	fprintln("Start of run");
	fprintState();
	CrossRight({<Goat>,<Farmer>});
	fprintln("Farmer crosses right with goat");
	fprintState();
	CrossLeft({<Farmer>});
	fprintln("Farmer returns alone");
	fprintState();
	CrossRight({<Cabbage>,<Farmer>});
	fprintln("Farmer crosses right with Cabbage");
	fprintState();
	CrossLeft({<Goat>,<Farmer>});
	fprintln("Farmer crosses left with Goat");
	fprintState();
	CrossRight({<Wolf>,<Farmer>});
	fprintln("Farmer crosses right with Wolf");
	fprintState();
	CrossRight({<Farmer>});
	fprintln("Farmer returns alone");
	fprintState();
	CrossRight({<Goat>,<Farmer>});
	fprintln("Farmer crosses right with Goat");
	fprintState();
	
  -- complete this operation by adding a sequence of steps to solve the puzzle
  -- solution can be found at
  -- https://illuminations.nctm.org/BrainTeasers.aspx?id=4992  
    );
    
    
    
-- Output functions - should not need to edit below this line
 values

outfile: seq of char = "crossing-run.txt";

 operations
 fopen: () ==> ()
 fopen() ==
  (dcl OK: bool;
   OK := IO`fecho(outfile, "", <start>);
   );
   
 fprint: seq of char ==> ()
 fprint(string) == 
  (dcl OK: bool;
   OK := IO`fecho(outfile, string, <append>););
 
 fprintln:  seq of char ==> ()
 fprintln(string) == fprint (string ^ "\n");
 
 fprintState:() ==> ()
 fprintState() == ( 
   fprintln("Crossing state:\n============");
   fprintln(toString(Crossing));
   );
 
   
types  -- build a union type for all types we might want to print
basic = int | nat | nat1 | real | bool | char | token;
defined = Passenger | Bank | Place | Crossing;
collection = set of basic | set of defined | seq of basic | seq of defined;
alltypes = basic | defined | collection

functions
 toString: alltypes -> seq of char
 toString(x) == 
   VDMUtil`val2seq_of_char[alltypes](x);  
   
end Crossing